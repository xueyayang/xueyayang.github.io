---
layout: default
---

静态变量存储在哪里？
====================

问题
----

VIM源码中的strerror函数，位于：

> vim74/src/os\_unix.c:line 2361

源码：

> \#if !defined(HAVE\_STRERROR) && defined(USE\_GETCWD) static char
> \*strerror \_\_ARGS((int));
> 
> static char \* strerror(err) int err; { extern int sys\_nerr;
> extern char \*sys\_errlist[]; static char er[20];
> 
> if (err \> 0 && err < sys\_nerr) return (sys\_errlist[err]);
> sprintf(er, "Error
> 
> return er; } \#endif

函数作用：根据传入的错误号，生在一段错误提示“字符串”。并返回。函数的返回值是一个字符指针，指向这个存储错误信息的地址。如果这个错误储存在一个临时变量的位置，那么从该函数返回后，自然内存也被释放了。这样就得不到错误信息。

因此这个函数用里：

1.  extern char {\*}sys\_errlist{[}{]} ，可以推测是个全局变量，通过''extern''
    关键字来访问。所以不存在内存被提前释放的问题。

2.  static char er{[}20{]}: 如果没有这个static
    关键字，er就是一个局部变量。为其分配的20个字节的内存，在函数退出后就要收回。返回值即使仍然指向这个地址，也不能得到正确的值。——已经被系统用作他用了。里面的内容是不可预知的。


可以看到，static起了很重要的作用。

之前知道：

1.  全局变量，或者用new/malloc的分配内存的变量，内存是在heap上的，不用担心被提前释放。

    1.  但问题是，如果没有人释放的话，一直也不会被释放。就是“内存泄露”了。


2.  局部变量的话，是在stack上，随时用，随时分配，但一旦出了“作用域”，就会自动被释放。


***所以问题很自然：局部静态变量，既不担心被提前释放，又不担心内存泄露，到底是存储在哪里的？为什么会有这优势？***

回答
====

静态变量既不在堆上，也不在栈上。而是有一个专门的地方来存放。

.o文件里的段与运行时内存布局
----------------------------

先认识一下两个阶段。源程序被编译(未链接)后，生成.o文件。这时面包含了data，text，bss等段。程序运行时，被加载进内存，这时候通常会说，变量位于heap/stack上。谈静态变量，在.o文件阶段，被分配在data/bss区；在内存阶段（运行时），被加载进“read/write
section”，可以认为是对应的data区。

data段、bss段及其它
-------------------

一个编译好的程序，最重要的是数据与指令，还有一些其它，都以`section`为区分，分开放。有不同的名字。几个常见的：

1.  .text section:
    存储程序指令。if...else...以及”+-×/“操作，被编译后，成为汇编指令，就放在这里。

2.  .data section: 存储程序的数据。比如：全局变量/静态变量。

3.  .rodata: 只读数据。比如：printf()函数里要输出的字符串。

4.  .comment: 注释信息。比如这句：`.GCC: (Ubuntu 4.4.3-4ubuntu5.1)
    4.4.3.`就记录了平台与编译器信息。


观察后文的dump结果，以对照。

是否初始化的区别
----------------

以编译后，生成的.o文件来看，全局变量与静态变量保存在哪里？根据初始化与未初始化，分为两种情况：

1.  初始化的全局变量/静态变量，，都放在.o文件的data区。

2.  未初化的全局变量/静态变量，是被区别对待的，记录在bss区。没有分配空间，没有给值，——因为现在还不知道他的值。


这样的话，明显的好处是，编译后的文件变小了。因为bss段并不增加.o文件的体积，只是记录了符号，记录其体积。在程序加载时，再进行分配。

验证
--------------

### 例子程序

源文件如下：

> //dig\_static.cpp
> 
> \#include<stdio.h\>
> 
> int g\_has\_val = 16; //.data section. 4-byte static int
> g\_static\_has\_value = 32;//.data section. 4-byte static char
> very\_long\_no\_value[128]; //.bss section. 128-byte but not
> assign
> 
> int main() { static int local\_static\_has\_value = 64; //data
> section. 4-byte static int local\_static\_no\_value; //.bss
> section. 4-byte but not assign //printf("do nothing!"); int
> sizeofint = sizeof(int); printf("int size is
> 
> }

### 编译命令

用命令

> gcc -x c -c dig\_static.cpp -o dig\_static.o

说明：

1.  -x c： 表明将dig\_static.cpp输入文件作为C语言来对待。故意命名为.cpp

2.  -c: 告诉编译器，只编译，不链接。链接的话，结果可能会有所同（编译器优化）。


### 查看

用命令

> objdump -h dig\_static.o

内容：

> eric@eric-desktop: /ATempTemp/CppProj/single\_temp$ objdump -h dig_static.o 
> 
> dig_static.o:     file format elf64-x86-64
> 
> Sections:
> Idx Name          Size      VMA               LMA               File off  Algn
>   0 .text         00000028  0000000000000000  0000000000000000  00000040  2**2
>                   CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
>   1 .data         0000000c  0000000000000000  0000000000000000  00000068  2**2
>                   CONTENTS, ALLOC, LOAD, DATA
>   2 .bss          00000084  0000000000000000  0000000000000000  00000080  2**5
>                   ALLOC
>   3 .rodata       00000011  0000000000000000  0000000000000000  00000080  2**0
>                   CONTENTS, ALLOC, LOAD, READONLY, DATA
>   4 .comment      00000026  0000000000000000  0000000000000000  00000091  2**0
>                   CONTENTS, READONLY
>   5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000b7  2**0
>                   CONTENTS, READONLY
>   6 .eh_frame     00000038  0000000000000000  0000000000000000  000000b8  2**3
>                   CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
> \end{lstlisting}
> 
> 
> 
> \subsubsection{分析}
> \begin{enumerate}
> \item 看几个点
> \item .data段： 0000000c。说明size是12byte。正好是三个has value的变量的值。
> \item .bss段： 00000084. 即128+4。正好是字符数组128,加上local\_static\_no\_value的长度。
> \end{enumerate}
> 
> \subsubsection{换个选项再出}
> 
> objdump还支持输出段中的具体内容，用选项-s：
> \begin{lstlisting}
> eric@eric-desktop:~/ATempTemp/CppProj/single_temp$
> objdump -s dig\_static.o
> 
> dig\_static.o: file format elf64-x86-64
> 
> Contents of section .data: 0000 10000000 20000000 40000000 ....
> ...@... Contents of section .rodata: 0000 696e7420 73697a65
> 20697320 2564210a int size is
> 
> 0010 00 Contents of section .comment: 0000 00474343 3a202855
> 62756e74 7520342e .GCC: (Ubuntu 4. 0010 342e332d 34756275 6e747535
> 2e312920 4.3-4ubuntu5.1) 0020 342e342e 3300 4.4.3.

分析：

1.  考虑Big Endian。所以值应该颠倒。如''10000000''正确的阅读顺序是''00001000''。

2.  Contents of section. data:

    1.  10000000: 颠倒后，是16.即变量g\_has\_val。

    2.  20000000：颠倒后，是32。即变量g\_static\_has\_value。

    3.  30000000: 颠倒后，是64。即变量local\_static\_has\_value。



### 其它

应该注释/放开不同的变量，多次编译&dump。以得到有效结论。

结论
====

1.  静态变量存储在一个专门的位置，不是heap，不是stack。

2.  静态变量与全局变量待遇“基本“相同

    1.  被初始化，放在data段。

    2.  未被初始化，放在bss段。

    3.  两个段的区别在于：是否被分配空间，即有效的增大了.o文件的体积。


3.  说基本相同是因为实验中，发现一个特殊现象：

    1.  有，且只有一个未被初始化的int全局变量时，bss段的size为0.

    2.  有，且只有一个未被初始化的int静态变量时，bss段的size为4.

    3.  原因有待进一步探究。可能要等读完《程序员的自身修养——链接、装载与库》后才能解答。





